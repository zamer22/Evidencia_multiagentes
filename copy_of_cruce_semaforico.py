# -*- coding: utf-8 -*-
"""Copy of Cruce_semaforico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qgeT-pNfXen-uWZL2EZbcpm1oHbGoBrc
"""

!pip install -q agentpy numpy matplotlib seaborn

import agentpy as ap
import numpy as np
from matplotlib import pyplot as plt
from matplotlib.patches import Wedge
import seaborn as sns
import random

# Configuración inicial para la animación y el estilo de los gráficos
sns.set(context="notebook", style="whitegrid")
plt.rcParams['animation.embed_limit'] = 50.0 # Aumenta el límite de tamaño de la animación a 50MB


PARAMS = {
    'steps': 600,             # Duración total de la simulación en segundos (ticks)

    # Parámetros del semáforo adaptativo
    'yellow': 3,              # Duración de la luz amarilla en segundos
    'all_red': 1,             # Duración de la fase "todo en rojo" para despejar el cruce
    'min_green': 10,          # Tiempo mínimo que una luz debe permanecer en verde
    'max_green': 60,          # Tiempo máximo antes de forzar un cambio de fase

    # Parámetros de Tráfico (tasa de llegada de coches por segundo)
    'lambda_N': 0.2, 'lambda_S': 0.2, # Tasa de llegada para Norte y Sur
    'lambda_E': 0.2, 'lambda_W': 0.2, # Tasa de llegada para Este y Oeste

    # Parámetros de los Vehículos
    'v_free': 7.0,            # Velocidad máxima de un coche en m/s
    'headway': 8.0,           # Distancia mínima de seguridad que un coche mantiene con el de adelante
    'u_turn_prob': 0.3,       # Probabilidad (0.0 a 1.0) de que un coche de N/S haga una vuelta en U

    # Geometría del Entorno
    'L': 80.0,                # Longitud de media calzada (desde el centro hasta el borde)
    'w': 3.5,                 # Ancho de un carril
    'lane_separation': 15.0,  # Ancho del camellón central que separa los carriles
    'roundabout_radius': 25.0 # Radio de la rotonda
}

class TrafficLightController(ap.Agent):
    """ Un controlador de semáforos que ajusta los tiempos de verde
    basado en la demanda de tráfico en tiempo real. """

    def setup(self):
        """ Inicializa los parámetros del controlador. """
        p = self.p
        self.yellow_time = int(p.yellow)
        self.all_red_time = int(p.all_red)
        self.min_green_time = int(p.min_green)
        self.max_green_time = int(p.max_green)

        # El estado inicial del sistema de semáforos
        self.phase = 0  # 0 = Fase Este-Oeste, 1 = Fase Norte-Sur
        self.sub_phase = 'G'  # 'G' (Verde), 'Y' (Amarillo), 'AR' (Todo en Rojo)
        self.timer = 0  # Temporizador para la sub-fase actual

    def get_light_states(self):
        """ Devuelve el estado (color) de cada una de las 6 luces. """
        lights = {d:'R' for d in ['N','S','E','W', 'N_exit', 'S_exit']}
        if self.sub_phase == 'AR':
            return lights

        if self.phase == 0:  # Fase Este-Oeste está activa
            lights['E'] = lights['W'] = self.sub_phase
            if self.sub_phase == 'G':
                # Las salidas N-S deben estar en verde para que los coches de E-W puedan salir
                lights['N_exit'] = lights['S_exit'] = 'G'
        else:  # Fase Norte-Sur está activa
            lights['N'] = lights['S'] = self.sub_phase
            # (No hay salidas E-W con semáforo en este modelo)

        return lights

    def count_waiting_cars(self):
        """ 'Mira' el tráfico y cuenta los coches esperando para entrar a la rotonda. """
        counts = {'N': 0, 'S': 0, 'E': 0, 'W': 0}
        waiting_states = ['approach', 'wait_light', 'wait_yield']
        for car in self.model.cars:
            if car.state in waiting_states and car.task == 'roundabout':
                counts[car.origin] += 1
        return counts

    def step(self):
        """ Lógica de decisión que se ejecuta en cada paso de la simulación. """
        # Las transiciones de Amarillo y Todo en Rojo son fijas
        if self.sub_phase == 'Y' and self.timer >= self.yellow_time:
            self.sub_phase, self.timer = 'AR', 0
            return
        elif self.sub_phase == 'AR' and self.timer >= self.all_red_time:
            self.phase = 1 if self.phase == 0 else 0  # Cambia a la otra fase
            self.sub_phase, self.timer = 'G', 0
            return

        # La lógica inteligente solo se aplica cuando una fase está en Verde
        if self.sub_phase == 'G':
            self.timer += 1
            # Regla 1: No cambiar si no se ha cumplido el tiempo mínimo en verde
            if self.timer < self.min_green_time:
                return

            # 'Sentidos': Obtener el estado actual del tráfico
            counts = self.count_waiting_cars()

            # Definir qué carriles están en verde y cuáles en rojo
            if self.phase == 0: # EW en Verde
                green_lanes_cars = counts['E'] + counts['W']
                red_lanes_cars = counts['N'] + counts['S']
            else: # NS en Verde
                green_lanes_cars = counts['N'] + counts['S']
                red_lanes_cars = counts['E'] + counts['W']

            # Regla 2: Forzar cambio si se alcanza el tiempo máximo
            force_change_by_time = self.timer >= self.max_green_time
            # Regla 3: Cambiar si el carril verde está vacío y hay demanda en el rojo
            change_by_efficiency = green_lanes_cars == 0 and red_lanes_cars > 0

            # Decisión final: si alguna regla de cambio se cumple, iniciar transición
            if force_change_by_time or change_by_efficiency:
                self.sub_phase, self.timer = 'Y', 0
        else:
            self.timer += 1

class Car(ap.Agent):
    """ Representa un vehículo individual con su propia lógica de movimiento y decisiones. """
    def setup(self, origin):
        # Inicialización de propiedades básicas
        self.origin = origin
        self.state = 'approach'
        self.v = 0 # Velocidad actual
        p = self.p
        L, w, R, sep = p.L, p.w, p.roundabout_radius, p.lane_separation

        # Calcula el desplazamiento del carril respecto al centro de la calle
        off = w / 2 + sep / 2

        # Define posición y dirección iniciales según el origen
        if origin == 'N':
            self.pos, self.dir = np.array([-off, L]), np.array([0, -1])
        elif origin == 'S':
            self.pos, self.dir = np.array([off, -L]), np.array([0, 1])
        elif origin == 'E':
            self.pos, self.dir = np.array([L, off]), np.array([-1, 0])
        else: # 'W'
            self.pos, self.dir = np.array([-L, -off]), np.array([1, 0])

        # Asigna una 'tarea' al coche: ir a la rotonda o hacer una vuelta en U (solo si es de N o S)
        self.task = 'roundabout'
        if origin in ['N', 'S'] and random.random() < p.u_turn_prob:
            self.task = 'u_turn'

        # Configura la geometría específica de la tarea
        if self.task == 'u_turn':
            u_turn_distance = 15.0
            if origin == 'N':
                self.u_turn_y = R + 2 + u_turn_distance
                self.goal, self.exit_dir = np.array([off, L]), np.array([0, 1])
            else: # South
                self.u_turn_y = -(R + 2 + u_turn_distance)
                self.goal, self.exit_dir = np.array([-off, -L]), np.array([0, -1])

            self.u_turn_point = np.array([self.pos[0], self.u_turn_y])
            self.u_turn_center = np.array([0, self.u_turn_y])
            self.u_turn_radius = off
            self.stopline = self.u_turn_point
            self.destination = origin
            self.passed_exit_light = True
        else: # Tarea: rotonda
            self.passed_exit_light = False
            self.stopline = np.array([self.pos[0], R + 2]) if origin == 'N' else \
                            np.array([self.pos[0], -(R + 2)]) if origin == 'S' else \
                            np.array([R + 2, self.pos[1]]) if origin == 'E' else \
                            np.array([-(R + 2), self.pos[1]])

            possible_destinations = [d for d in ['N', 'S', 'E', 'W'] if d != self.origin]
            self.destination = random.choice(possible_destinations)

            if self.destination == 'N':
                self.goal, self.exit_dir = np.array([off, L]), np.array([0, 1])
                self.exit_pos = np.array([off, np.sqrt(R**2 - off**2)])
            elif self.destination == 'S':
                self.goal, self.exit_dir = np.array([-off, -L]), np.array([0, -1])
                self.exit_pos = np.array([-off, -np.sqrt(R**2 - off**2)])
            elif self.destination == 'E':
                self.goal, self.exit_dir = np.array([L, -off]), np.array([1, 0])
                self.exit_pos = np.array([np.sqrt(R**2 - off**2), -off])
            else: # 'W'
                self.goal, self.exit_dir = np.array([-L, off]), np.array([-1, 0])
                self.exit_pos = np.array([-np.sqrt(R**2 - off**2), off])

            self.exit_stopline = self.exit_pos + self.exit_dir * (w + 2)
            self.entry_pos = np.array([self.pos[0], np.sqrt(R**2 - off**2)]) if origin == 'N' else \
                             np.array([self.pos[0], -np.sqrt(R**2 - off**2)]) if origin == 'S' else \
                             np.array([np.sqrt(R**2 - off**2), self.pos[1]]) if origin == 'E' else \
                             np.array([-np.sqrt(R**2 - off**2), self.pos[1]])

            self.entry_angle = np.arctan2(self.entry_pos[1], self.entry_pos[0])
            self.exit_angle = np.arctan2(self.exit_pos[1], self.exit_pos[0])
            self.current_angle = self.entry_angle
            if self.exit_angle <= self.entry_angle:
                self.exit_angle += 2 * np.pi

    def dist_to(self, p): return np.linalg.norm(self.pos - p)

    def step(self):
        """ Lógica de movimiento y cambio de estado del coche en cada paso. """
        if self.state == 'done': return
        self.v = self.p.v_free
        R = self.p.roundabout_radius
        lights = self.model.ctrl.get_light_states()

        if self.state == 'approach':
            target_point = self.u_turn_point if self.task == 'u_turn' else self.stopline
            if self.dist_to(target_point) <= self.v:
                if self.task == 'u_turn':
                    self.state = 'in_u_turn'
                    if self.origin == 'N': self.current_angle = np.pi
                    else: self.current_angle = 0
                else:
                    if not self.model.headway_ahead(self): self.pos = self.stopline.copy()
                    if lights[self.origin] != 'G': self.state = 'wait_light'
                    else: self.state = 'wait_yield'
                self.v = 0; return
            head = self.model.headway_ahead(self)
            if head: self.v = min(self.v, max(0, self.dist_to(head.pos) - self.p.headway))
            self.pos += self.dir * self.v

        elif self.state == 'in_u_turn':
            angular_velocity = self.v / self.u_turn_radius; exit_condition = False
            if self.origin == 'N':
                self.current_angle += angular_velocity
                if self.current_angle >= 2 * np.pi: exit_condition = True
            else:
                self.current_angle += angular_velocity
                if self.current_angle >= np.pi: exit_condition = True
            self.pos[0] = self.u_turn_center[0] + self.u_turn_radius * np.cos(self.current_angle)
            self.pos[1] = self.u_turn_center[1] + self.u_turn_radius * np.sin(self.current_angle)
            if exit_condition:
                self.state = 'exit'; self.pos[0] = self.goal[0] ; self.pos[1] = self.u_turn_y
            self.v = self.p.v_free if not exit_condition else 0

        elif self.state == 'wait_light':
            self.v = 0
            if lights[self.origin] == 'G': self.state = 'wait_yield'

        elif self.state == 'wait_yield':
            self.v = 0
            if lights[self.origin] != 'G': self.state = 'wait_light'; return
            if not self.model.check_roundabout_conflict(self):
                self.state = 'in_roundabout'; self.entry_angle = np.arctan2(self.pos[1], self.pos[0]); self.current_angle = self.entry_angle

        elif self.state == 'in_roundabout':
            head = self.model.headway_in_roundabout(self)
            if head:
                angular_sep = (head.current_angle - self.current_angle) % (2 * np.pi); arc_distance = angular_sep * R
                self.v = min(self.v, max(0, arc_distance - self.p.headway))
            next_angle = self.current_angle + (self.v / R if R > 0 else 0)
            if next_angle >= self.exit_angle:
                if self.model.is_exit_blocked(self):
                    angle_to_exit = self.exit_angle - self.current_angle; dist_to_exit = angle_to_exit * R
                    self.v = min(self.v, dist_to_exit)
                else:
                    self.state = 'exit'; self.pos = self.exit_pos.copy(); self.v = 0; return
            if self.v > 0:
                angular_velocity = self.v / R; self.current_angle += angular_velocity
                self.pos[0] = R * np.cos(self.current_angle); self.pos[1] = R * np.sin(self.current_angle)

        elif self.state == 'wait_exit_light':
            self.v = 0
            exit_light_id = f"{self.destination}_exit"
            if lights.get(exit_light_id) == 'G':
                self.state = 'exit'

        elif self.state == 'exit':
            target_point = self.goal
            if self.task == 'roundabout' and not self.passed_exit_light:
                target_point = self.exit_stopline
                if self.dist_to(self.exit_stopline) < 1.0:
                    exit_light_id = f"{self.destination}_exit"
                    if lights.get(exit_light_id, 'G') != 'G':
                        self.state = 'wait_exit_light'; self.pos = self.exit_stopline.copy(); self.v = 0; return
                    else:
                        self.passed_exit_light = True
            head = self.model.headway_ahead(self)
            if head: self.v = min(self.v, max(0, self.dist_to(head.pos) - self.p.headway))
            dist_to_target = self.dist_to(target_point); self.v = min(self.v, dist_to_target)
            self.pos += self.exit_dir * self.v
            if self.dist_to(self.goal) < 1.0:
                self.state = 'done'; self.v = 0

class SimulationModel(ap.Model):
    def setup(self):
        """ Configura el estado inicial de la simulación. """
        self.ctrl = TrafficLightController(self)
        self.cars = ap.AgentList(self, 0, Car)

    def step(self):
        """ Define las acciones que ocurren en cada paso de la simulación. """
        # 1. Generar nuevos coches
        self.spawn_poisson('N', self.p.lambda_N)
        self.spawn_poisson('S', self.p.lambda_S)
        self.spawn_poisson('E', self.p.lambda_E)
        self.spawn_poisson('W', self.p.lambda_W)

        # 2. Actualizar el estado del semáforo
        self.ctrl.step()

        # 3. Mover los coches
        self.cars.step()

        # 4. Eliminar coches que ya terminaron
        self.cars = ap.AgentList(self, [c for c in self.cars if c.state != 'done'])

    def spawn_poisson(self, origin, lam):
        """ Crea k nuevos coches basados en una distribución de Poisson. """
        k = np.random.poisson(lam)
        for _ in range(k):
            self.cars.append(Car(self, origin=origin))

    # --- Funciones de Percepción para los Agentes ---

    def headway_ahead(self, me):
        """ Encuentra el coche líder más cercano en un carril recto. """
        approaching_states = ['approach', 'wait_light', 'wait_yield', 'in_u_turn']
        exiting_states = ['exit', 'wait_exit_light']

        if me.state in approaching_states:
            cars_to_consider = [c for c in self.cars if c.state in approaching_states]
            current_dir = me.dir
            same_lane_cars = [c for c in cars_to_consider if c is not me and np.allclose(c.dir, current_dir)]
        elif me.state in exiting_states:
            cars_to_consider = [c for c in self.cars if c.state in exiting_states]
            current_dir = me.exit_dir
            same_lane_cars = [c for c in cars_to_consider if c is not me and np.allclose(c.exit_dir, current_dir)]
        else:
            return None

        if not same_lane_cars: return None

        ahead = [(np.dot(c.pos - me.pos, current_dir), c) for c in same_lane_cars]
        ahead = [item for item in ahead if item[0] > 0.1]
        return min(ahead, key=lambda x: x[0])[1] if ahead else None

    def is_exit_blocked(self, car_exiting):
        """ Revisa si la entrada al carril de salida está bloqueada. """
        exit_pos = car_exiting.exit_pos
        exit_dir = car_exiting.exit_dir
        exiting_cars = [c for c in self.cars if c.state in ['exit', 'wait_exit_light']]
        for other in exiting_cars:
            if np.allclose(other.exit_dir, exit_dir):
                if np.linalg.norm(other.pos - exit_pos) < self.p.headway:
                    return True
        return False

    def headway_in_roundabout(self, me):
        """ Encuentra al coche líder más cercano dentro de la rotonda. """
        roundabout_cars = [c for c in self.cars if c.state == 'in_roundabout' and c is not me]
        if not roundabout_cars: return None
        ahead = []
        for other in roundabout_cars:
            angular_sep = (other.current_angle - me.current_angle) % (2 * np.pi)
            if angular_sep > 0.01: ahead.append((angular_sep, other))
        if not ahead: return None
        return min(ahead, key=lambda x: x[0])[1]

    def check_roundabout_conflict(self, car_entering):
        """ Revisa si hay coches en la 'zona de peligro' para ceder el paso. """
        entry_angle = car_entering.entry_angle
        # Zona de peligro: desde 20 grados adelante hasta 45 grados atrás
        conflict_ahead = np.deg2rad(20)
        conflict_behind = np.deg2rad(45)

        for other in self.cars:
            if other.state == 'in_roundabout':
                delta = (other.current_angle - entry_angle + np.pi) % (2 * np.pi) - np.pi
                if -conflict_ahead < delta < conflict_behind:
                    return True
        return False

def draw_intersection(ax, p):
    """ Dibuja el fondo estático del mapa. """
    L, w, R, sep = p.L, p.w, p.roundabout_radius, p.lane_separation
    ax.clear()
    ax.set_xlim(-L, L); ax.set_ylim(-L, L)
    ax.set_aspect('equal')
    ax.set_xticks([]); ax.set_yticks([])
    ax.set_title(f"Simulación de Rotonda con Vueltas en U | t = {model.t}s")

    # Dibuja camellones y carriles
    ax.add_patch(plt.Rectangle((-L, -sep/2), 2*L, sep, color='#a9a9a9', zorder=0))
    ax.add_patch(plt.Rectangle((-sep/2, -L), sep, 2*L, color='#a9a9a9', zorder=0))
    ax.add_patch(plt.Rectangle((-L, sep/2), 2*L, w, color='#cccccc', zorder=0))
    ax.add_patch(plt.Rectangle((-L, -sep/2 - w), 2*L, w, color='#cccccc', zorder=0))
    ax.add_patch(plt.Rectangle((sep/2, -L), w, 2*L, color='#cccccc', zorder=0))
    ax.add_patch(plt.Rectangle((-sep/2 - w, -L), w, 2*L, color='#cccccc', zorder=0))

    # Dibuja bahías de vuelta en U
    u_turn_distance = 15.0
    off = w / 2 + sep / 2
    y_n = R + 2 + u_turn_distance
    center_n = (0, y_n)
    ax.add_patch(Wedge(center_n, off + w/2, 180, 360, width=w, color='#cccccc', zorder=0))
    y_s = -(R + 2 + u_turn_distance)
    center_s = (0, y_s)
    ax.add_patch(Wedge(center_s, off + w/2, 0, 180, width=w, color='#cccccc', zorder=0))

    # Dibuja la rotonda
    ax.add_patch(plt.Circle((0,0), R + w, facecolor='#cccccc', zorder=1))
    ax.add_patch(plt.Circle((0,0), R - w, facecolor='#dcedc8', zorder=1))

    # Dibuja líneas de alto
    for origin, pos, size in [('N', [-off, R+2], w), ('S', [off, -(R+2)], w), ('E', [R+2, off], w), ('W', [-(R+2), -off], w)]:
        if origin in ['N', 'S']: ax.plot([pos[0]-size/2, pos[0]+size/2], [pos[1], pos[1]], color='white', lw=3, zorder=2)
        else: ax.plot([pos[0], pos[0]], [pos[1]-size/2, pos[1]+size/2], color='white', lw=3, zorder=2)

    exit_stop_dist = w + 2
    exit_n_pos = np.array([off, np.sqrt(R**2 - off**2)]) + np.array([0, 1]) * exit_stop_dist
    ax.plot([exit_n_pos[0]-w/2, exit_n_pos[0]+w/2], [exit_n_pos[1], exit_n_pos[1]], color='yellow', lw=3, zorder=2)
    exit_s_pos = np.array([-off, -np.sqrt(R**2 - off**2)]) + np.array([0, -1]) * exit_stop_dist
    ax.plot([exit_s_pos[0]-w/2, exit_s_pos[0]+w/2], [exit_s_pos[1], exit_s_pos[1]], color='yellow', lw=3, zorder=2)

def my_plot(m, ax):
    """ Dibuja los elementos dinámicos (coches y luces) sobre el mapa. """
    p = m.p
    draw_intersection(ax, p)

    lights = m.ctrl.get_light_states()
    color_map = {'R':'#d32f2f','Y':'#f9a825','G':'#388e3c'}

    off = p.w / 2 + p.lane_separation / 2
    R = p.roundabout_radius
    exit_stop_dist = p.w + 2
    exit_n_y = np.sqrt(R**2 - off**2) + exit_stop_dist
    exit_s_y = -np.sqrt(R**2 - off**2) - exit_stop_dist

    # Posiciones de todas las luces
    locs = {
        'N':(-off, R+4), 'S':(off, -(R+4)), 'E':(R+4, off), 'W':(-(R+4), -off),
        'N_exit':(off, exit_n_y + 2), 'S_exit':(-off, exit_s_y - 2)
    }

    for d,(x,y) in locs.items():
        light_state = lights.get(d)
        if light_state: ax.add_patch(plt.Circle((x,y), 1.2, color=color_map[light_state], zorder=3))

    # Dibuja los coches con un color que representa su estado actual
    if len(m.cars) > 0:
        state_colors = {
            'approach': '#1976d2', 'wait_light': '#c62828', 'wait_yield': '#f9a825',
            'in_roundabout': '#00897b', 'exit': '#1e88e5', 'done': 'gray',
            'in_u_turn': '#6a1b9a', 'wait_exit_light': '#ff7043'
        }
        cs = [state_colors.get(c.state, 'black') for c in m.cars]
        ax.scatter([c.pos[0] for c in m.cars], [c.pos[1] for c in m.cars], s=40, c=cs, edgecolor='k', linewidth=0.5, zorder=4)

fig, ax = plt.subplots(figsize=(8,8)) # Un poco más grande para mejor visualización
model = SimulationModel(PARAMS)
anim = ap.animate(model, fig, ax, my_plot)
from IPython.display import HTML
HTML(anim.to_jshtml())